---
title: "Group Matching ABM"
author: "Clara Lavrador"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true 
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Model Overview

### Purpose

So basically, I want to see if study groups become smaller and more interconnected over time. Each agent will have a group value (based on their grade for now; later will do by priority/preference). So the gv is how much value they offer a group. I'll normalize grade somehow. After they receive their initial grade, agents will send out an offer to 2 other agents. Idk if they will randomly select those or just find the ones with best gv? Idk. Or all of them. Anyway, whether or not they pursue is based on the group value times the alliance.  


### Agents 




### Life Cycle

## Model

### Packages 
```{r packages}

```


### Parameters
```{r parameters}

popSize <- 275

pursuitRange <- c(1:5)

numTests <- 6

w <- 0.5

grades <- c(1:5)

```


### Functions
```{r functions}

#Agent Generate Function#
agentGenerate <- function(n){
  
  grade <- NA
  
#  social <- sample(c(1:100), n, replace = T)
  
  commitment <- sample(c(1:5), n, replace = T)
  
  conformity <- sample(c(1:5), n, replace = T)
  
  agents <- data.frame(grade, commitment, conformity)
  
  return(agents)
  
}


#Grade Skew Function#
#define probabilities based on commitment levels
grade_prob <- function(commitment) {
  switch(as.character(commitment),
         "5" = c(0.05, 0.10, 0.20, 0.30, 0.35),  # low commitment = higher chance of F
         "4" = c(0.10, 0.15, 0.20, 0.30, 0.25),
         "3" = c(0.15, 0.20, 0.25, 0.25, 0.15),
         "2" = c(0.20, 0.30, 0.30, 0.15, 0.05),
         "1" = c(0.35, 0.35, 0.20, 0.05, 0.05))  # high commitment = higher chance of A or B
}



#Normalize Value Function#

normalize <- function(value){
  
  n_group_values <- (value + 100)/200
  
  return(n_group_values)
}
 
 
#Group Value Function#

groupVal <- function(agents, pursuit_values){
  
    commitment_a <- agents$commitment[a]
    conformity_a <- agents$conformity[a]
    grade_a <- agents$grade[a]

  for(b in 1:nrow(pursuit_values)){
    
    grade_b <- agents$grade[b]
    
    objective = (grade_b / 5) * commitment_a
    similarity = (1 - (abs(grade_a - grade_b) / 4)) * conformity_a
    group_value <- ((commitment_a / (commitment_a + conformity_a)) * objective) + ((commitment_a / (commitment_a + conformity_a)) *similarity)
    
    pursuit_values$group_value[b] <- group_value
    
  }
  
    return(pursuit_values)
    
}



 
#Overlap Function#

overlap <- function(agent, adjMat){
  
  for(b in 1:nrow(adjMat)){
    
    if(b != agent){
      
      #Alliance#
      #compare the two rows, taking the column wise minimum value, and then add it together
      alliances <- pmin(adjMat[agent, ], adjMat[b, ])
      alliance <- sum(alliances)
      
      #Generalization#
      #compare the two columns, taking the minimum value of each row and adding it up
      generalizations <- pmin(adjMat[ ,agent], adjMat[ ,b])
      generalization <- sum(generalizations)

      #Displacement#
      #compare agent a's row with agent b's column
      displacements <- pmin(adjMat[agent, ], adjMat[, b])
      displacement <- sum(displacements)

      #Defense#
      #compare agent a's column with agent b's row
      defenses <- pmin(adjMat[, agent], adjMat[b, ])
      defense <- sum(defenses)

      #Overlap Score#
      #sum the 4 primitives scores
      overlap_score <- sum(alliance, generalization, displacement, defense)


      #add pursuit value to respective row
      pursuit_values$overlap_score[b] <- overlap_score
      
      
    } 
    
    
  }
  
  return(pursuit_values)
  
}





```


### Life Cycle
```{r lifeCycle}

agents <- agentGenerate(popSize)

adjMat <- matrix(0, nrow = popSize, ncol = popSize)

#adjMat <- matrix(sample(1:5, 10*10, replace = TRUE), nrow = 10, ncol = 10)

matrix_list <- list(adjMat)
noncumMat_list <- list(adjMat)
results <- data.frame("test" = rep(1:numTests, each = nrow(agents)),
                      "agent" = 1:nrow(agents),
                      "grade" = NA)


for(t in 2:numTests) {
  
  noncumMat <- matrix(0, nrow = popSize, ncol = popSize)
  
  #Receive Grade#
  #each agent gets test grade based on their commitment level
  for (a in 1:nrow(agents)) {
    
    agents$grade[a] <- sample(grades, size = 1, prob = grade_prob(agents$commitment[a]))
    
    results$grade[results$test == t-1 & results$agent == a] <- agents$grade[a]

    
  }
  
  #Calculate Group Values and Alliance Values#
  for (a in 1:nrow(agents)) {
    
    pursuit_values <- data.frame(
      "agent_b" = 1:nrow(agents),
      "group_value" = NA,
      "overlap_score" = NA
    )
    
    #Group Values#
    #get a vector of the group values of other agents with respect to agent a
    pursuit_values <- groupVal(agents, pursuit_values)
  
    
    #Overlap Scores#
    #base the overlap on the previous adjacency matrix, so that all agents can fill it without affecting the others within this time step
    pursuit_values <- overlap(a, matrix_list[[t-1]])
    
    
    #Pursuit Value#
    #multiply group value and overlap score to get pursuit value
    pursuit_values$pursuit_value <- ifelse(pursuit_values$overlap_score > 0, pursuit_values$group_value * pursuit_values$overlap_score, pursuit_values$group_value * 1)
    
    #Randomize number of pursuits for the agent
    pursuitAmount <- sample(pursuitRange, 1, replace = T)
    
    #sort by product in descending order and get the indices of the top agents
    pursuit_indices <- order(-pursuit_values$pursuit_value)[1:pursuitAmount]
    
    
    #add them to the adjacency matrix
    adjMat[a, pursuit_indices] <- adjMat[a, pursuit_indices] + 1
    
    
    noncumMat[a, pursuit_indices] <- 1
    
    
  }
  
  matrix_list[[t]] <- adjMat
  
  noncumMat_list[[t]] <- noncumMat
  
}



```


### Analysis
```{r analysis}


igraph_list <- lapply(noncumMat_list, graph_from_adjacency_matrix) 



#keep only reciprocal edges


for(g in 1:length(igraph_list)){
  
  igraph_list[[g]] <- subgraph.edges(igraph_list[[g]], E(igraph_list[[g]])[which_mutual(igraph_list[[g]])], delete.vertices = F)
  
}




plot(igraph_list[[3]], 
     layout = layout.fruchterman.reingold, 
     vertex.label = NA,
     #  rescale = F,
     layout = layout_with_kk,
     vertex.size = 8,
     vertex.label.color = "grey25",
     vertex.shape = "circle",
     edge.arrow.size = 0.3)


graph_stats_abm <- do.call(rbind, lapply(igraph_list, function(g){
  
  components <- components(g)
  
  data.frame(
    
    num_vertices = vcount(g),
    num_edges = ecount(g),
    transitivity = transitivity(g),
    avg_degree = mean(degree(g)),
    avg_edges = ecount(g)/vcount(g),
    num_groups = components$no,
    group_sizes = mean(components$csize)
    
  )
    
}))



p1 <- ggplot(data = graph_stats_abm,
       aes(x = examnum,
           y = avg_edges)) +
  labs(x = "Exam Number",
       y = "Average Number of Edges"
       ) +
  geom_point() +
  geom_line()

plot(p1)





length(E(igraph_list[[9]])[which_mutual(igraph_list[[9]])])

length(E(igraph_list[[9]])[which_mutual(igraph_list[[9]])])


for(i in 1:length(igraph_list)){
  
  length <- length(E(igraph_list[[i]])[which_mutual(igraph_list[[i]])])
  
  print(length)
  
}


for(i in 1:length(igraph_list)){
  
  length <- count_triangles(igraph_list[[i]])
  
  print(length)
  
}




network_list <- lapply(noncumMat_list, as.network)

for(i in 1:length(network_list)){
  
  network_list[i] <- count_triangles(igraph_list[[i]])
  
  print(length)
  
}


reciprocal_graph <- subgraph.edges(igraph_list[[g]], E(igraph_list[[g]])[which_mutual(igraph_list[[g]])], delete.vertices = F)

network_dynamic <- networkDynamic(network.list = network_list, create.TEAs = TRUE)

plot(network_dynamic)

render.d3movie(network_dynamic)

```









