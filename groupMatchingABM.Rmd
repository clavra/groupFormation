---
title: "groupFormation"
author: "Clara Lavrador"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Model Overview

### Purpose


### Agents

Each agent will have a set of three traits and three preferences, which are randomly assigned from 0-100. 
They will also have a number of pursuits they can make per regrouping period.


### Life Cycle

1. Gather info
2. Pursue agents
3. Regroup

#### Gather info

Each agent will calculate three scores with respect to other agents: association value, reciprocity score, and overlap score.

The association value is calculated by taking the euclidean distance of the agent's preferences with the other agents' traits. 

The reciprocity score is the proportion of pursuits between the agent and each other agent that are reciprocated.

The overlap score is a measurement of pursuit similarity (both sent and received) between the agent and each other agent, with respect to third parties.
  It is based on David Pietraszewski's triadic primitives, whereby:
   
     association is the correlation between the agent and each other agents' sent pursuits (i.e., how much they pursue the same agents)
     
     generalization is the correlation between the agent and each other agents' received pursuits (i.e., how much they are pursued by the same agents)
     
     displacement is the correlation between the agent's sent pursuits and each other agents' received pursuits (i.e., how much the agents that agent b pursues pursue agent a)
     
     defense is the correlation between the agent's received and each other agents' sent pursuits (i.e., how much the agents that agent a is pursued by are pursued by agent b)

  
These three scores are then formulated to produce a single pursuit score:

  pursuit value = association value + (reciprocity score + overlap score)


#### Pursue agents

Each agent will pursue the agents with the highest pursuit values. 

Sent and received pursuits will be accumulated (and thus used to calculate overlap in the next reassessment period) 

#### Regroup

Agents who have reciprocated pursuits with each other will be considered "grouped" together for that reassessment period.

Then it all begins anew until the max number of reassessment periods has been reached.


### Analysis

For now I'm plotting the number of reciprocated edges over time across all model loops.
But I must think of a better representation... number of groups only tells half the story (bc they still differ in size)

Best thing would be to see if the model loops converge in some other aspect(s)

Also I could compare it to a model that does not include overlap score



## Model

### Packages 
```{r packages}

library(ggplot2)
library(igraph)
library(network)
library(networkDynamic)
library(intergraph)
library(ndtv)

```


### Parameters
```{r parameters}

#number of agents to generate
popSize <- 100

#pursuitRange <- c(1:5)

#number of pursuits each agent will have for each reassessment period
pursuitAmount <- 3

#number of times agents will reevaluate their pursuits
reassessments <- 300

#number of loops for the whole model
modelLoops <- 1

#list the four primitives...
all_primitives <- c("alliance", "displacement", "defense", "generalization")

#make list of all possible combinations of the prims
all_combos <- unlist(
  lapply(1:length(all_primitives), function(k) {
    combn(all_primitives, k, simplify = FALSE)
  }),
  recursive = FALSE
)

#add the null option
all_combos <- c(all_combos, "XX")

#list the prim combo abbreviations in order to append later
prim_abbrev <- c("A",
"P",
"D",
"G",
"AP",
"AD",
"AG",
"PD",
"PG",
"DG",
"APD",
"APG",
"ADG",
"PDG",
"APDG",
"XX")

primies <- as.data.frame(prim_abbrev)

#conditions to test

AV_SD <- 0.05


```


### Functions
```{r functions}


#Agent Generate Function#

agentGenerate <- function(n){
  
  #randomly generate 3 traits and their corresponding preferences for each agent

  association <- abs(rnorm(popSize, mean = 50, sd = 10))
  
  association <- round(association, digits = 0)
  
  association <- (association/100)
  
  pursuit_amount <- sample(2:5, n, replace = T)
  
  #put it all together in a df
  agents <- data.frame(association, pursuit_amount)
  
  return(agents)
  
}

makeAssociationMat <- function(agentDF, sd){
  
  associationMat <- matrix(, nrow = popSize, ncol = popSize)
  
  for(a in 1:nrow(agentDF)){
    
    associationMat[,a] <-  rnorm(popSize, mean = agentDF$association[a], sd = sd)
    
  }
  
  diag(associationMat) <- NA
  
  return(associationMat)
  
}
  

weighted_jaccard <- function(x, y) {
  
  # Calculate the numerator: Sum of minimum intensities
  numerator <- sum(pmin(x, y))
  
  # Calculate the denominator: Sum of maximum intensities
  denominator <- sum(pmax(x, y))
  
  # Handle edge case where denominator is 0 (all zeros)
  if (denominator == 0) return(0)
  
  # Calculate weighted Jaccard similarity
  similarity <- numerator / denominator
  return(similarity)
}


#Overlap Score Function#
#calculates overlap between input agent and all other agents by comparing their sent and received pursuits; based on Dave's triadic primitives
#choose components to use in calculation

overlap <- function(agent, adjMat, component) {
  
  scores <- switch(component,
    

    #Alliance#
    #calculate correlation of agent's row with other agents' rows 
      "alliance" = sapply(1:nrow(adjMat), function(i) {
        if (i == agent)
          return(NA)
        exclude_indices <- c(agent, i)
        x_filtered <- adjMat[i,-exclude_indices]
        agent_row_filtered <- adjMat[agent,-exclude_indices]
        weighted_jaccard(x_filtered, agent_row_filtered)
      }),
    
    
    #Generalization#
    #calculate correlation of agent's column with other agents' columns
      "generalization" = sapply(1:ncol(adjMat), function(j) {
        if (j == agent)
          return(NA)
        exclude_indices <- c(agent, j)
        x_filtered <- adjMat[-exclude_indices, j]
        agent_filtered <- adjMat[-exclude_indices, agent]
        weighted_jaccard(x_filtered, agent_filtered)
      }),
    
    #Displacement#
    #calculate correlation of agent's row with other agents' columns
      "displacement" = sapply(1:nrow(adjMat), function(j) {
        if (j == agent) #transpose not valid for this and defense
          return(NA)
        exclude_indices <- c(agent, j)
        x_filtered <- adjMat[-exclude_indices, j]
        agent_filtered <- adjMat[agent,-exclude_indices]
        weighted_jaccard(x_filtered, agent_filtered)
      }),
    
    #Defense#
    #calculate correlation of agent's column with other agents' rows
      "defense" = sapply(1:ncol(adjMat), function(i) {
        if (i == agent)
          return(NA)
        exclude_indices <- c(agent, i)
        x_filtered <- adjMat[i,-exclude_indices]
        agent_filtered <- adjMat[-exclude_indices, agent]
        weighted_jaccard(x_filtered, agent_filtered)
      })
  )

    return(scores)
  
  }




#Reciprocity Function#

reciprocity <- function(agent, adjMat){
  
  #pull agent's column which represents their received pursuits
  received <- adjMat[,agent]
  
  #pull agent's row which represents their sent pursuits
  sent <- adjMat[agent,]
    
  #calculate proportions of pursuits which were received
  reciprocity_scores <- (received / (received + sent))
  
  #nullify their own reciprocity score
  reciprocity_scores[agent] <- NA
  
  return(reciprocity_scores)
  
}
  


```


### Life Cycle

```{r lifeCycle}

start.time <- Sys.time()

#initialize results df
results <- data.frame("loop" = rep(1:modelLoops, each = length(all_combos) * reassessments),
                      "combo" = rep(1:length(all_combos),each = reassessments),
                      "reassess" = rep(1:reassessments),
                      "num_isolates" = NA,
                      "num_groups" = NA,
                      "num_four" = NA,
                      "assort_association" = NA)

lastGraphs <- c()


for(m in 1:modelLoops) {
  
  print(m)
  
  #Generate agents
  agents <- agentGenerate(popSize)
  
  #make association matrix which gives agents slightly different perceptions of each others' AVs
  associationMat <- makeAssociationMat(agents, AV_SD)
  
  #run for all possible primitive combos
  for (c in 1:length(all_combos)) {
    
    print(c)
    
    #get the primitives that correspond to that combo
    primitives <- all_combos[[c]]
    
    #generate adjacency matrix (populate with 1)
    adjMat <- matrix(1, nrow = popSize, ncol = popSize)
    
    #store each reassessment period's cumulative adjacency matrix so that agents can reference the previous one when calculating their overlap/reciprocal scores
    matrix_list <- list(adjMat)
    
    #initialize list to store each reassessment's adjacency matrix as binary for that iteration so we can look at who was reciprocal at each reassessment period
    noncumMat_list <- list(adjMat)
    
    friendsMat_list <- list(adjMat)
    
    
    #for each reassessment... (agents look backwards so start from 2)
    for (t in 2:reassessments) {
      
      #create the empty noncumulative adjacency matrix
      noncumMat <- matrix(0, nrow = popSize, ncol = popSize)
    
      # Calculate overlap in previous adjacency matrix #
      
      #if we are not on the null primitive...
      if (!primitives[1] == "XX") {
        
        #make empty matrix list
        overlap_matrices <- list()
        
        #for each primitive you will be using...
        for (prim in primitives) {
          
          #create a matrix for that primitive
          overlap_matrices[[prim]] <- matrix(NA, nrow = popSize, ncol = popSize)
          
          #use overlap function to calculate overlap for that primitive
          for (r in 1:nrow(overlap_matrices[[prim]])) {
            overlap_matrices[[prim]][r,] <- overlap(r, matrix_list[[t - 1]], prim)
          }
        }
        
        
        #calculate the final overlap score matrix
        final_overlap_matrix <- Reduce("+", lapply(primitives, function(prim) overlap_matrices[[prim]])) / length(primitives)
        
        #for the null primitive, make overlap matrix filled with 1 (will have no effect when multiplied in pursuit val calculation)
      } else {
        final_overlap_matrix <- matrix(1, nrow = popSize, ncol = popSize)
      }
      
      #Loop through each agent to compute their pursuits
      
      #for each agent...
      for (a in 1:nrow(agents)) {
        #pull the overlap scores between themselves and the other agents from the final overlap matrix
        overlap_scores <- final_overlap_matrix[a, ]
        
        #calculate the reciprocity scores between themselves and the other agents
        reciprocity_scores <- reciprocity(a, matrix_list[[t - 1]])
        
        #calculate the association values between their prefs and the other agents' traits
        association_values <- associationMat[a,]
        
        #Combine overlap, reciprocity, and association scores into single calculation
        pursuit_scores <- overlap_scores * reciprocity_scores * association_values
        
        #Randomize number of pursuits for the agent
        pursuitAmount <- pursuitAmount
        
        #sort by product in descending order and get the indices of the top value agents
        pursuit_indices <- order(-pursuit_scores)[1:pursuitAmount]
        
        #add 1 to their pursuits in the cumulative the adjacency matrix
        adjMat[a, pursuit_indices] <- adjMat[a, pursuit_indices] + 1
        
        #and to the individual one
        noncumMat[a, pursuit_indices] <- 1
        
        
        
      }
      
      #add the adjMat to the matrix list
      matrix_list[[t]] <- adjMat
      
      #add the non cumulative matrix to its list
      noncumMat_list[[t]] <- noncumMat
      
      #make matrix that has only reciprocated ties
      friendsMatrix <- noncumMat * t(noncumMat)

      friendsMat_list[[t]] <- friendsMatrix

      
    }
    
    

    igraph_list <-
      lapply(friendsMat_list,
             graph_from_adjacency_matrix,
             mode = "undirected")

    

    
    #loop through each igraph object
    for (g in 1:length(igraph_list)) {

      #only include edges that are reciprocated
      igraph_list[[g]] <- subgraph_from_edges(igraph_list[[g]],
                                         E(igraph_list[[g]])[which_mutual(igraph_list[[g]])],
                                         delete.vertices = F) #maybe i can just do this with true to get groups

      V(igraph_list[[g]])$name <- c(1:100)
      
      V(igraph_list[[g]])$association <- agents$association[match(V(igraph_list[[g]])$name, rownames(agents))]
      
      
      #get total number of edges
      numEdges <- length(E(igraph_list[[g]]))
      
      
      #get edge overlap with previous graph
      intersectLast <- ifelse(g > 1, length(E(intersection(igraph_list[[g - 1]], igraph_list[[g]]))), NA)
      
      #get number of groups
      num_groups <- igraph::components(igraph_list[[g]])$no
      
      #get number of isolates
      num_isolates <- length(max_cliques(igraph_list[[g]], min = 1, max = 1))
      
      #get number of closed groups of 4
      num_four <-length(max_cliques(igraph_list[[g]], min = 4, max = 4))
      
   
      
      #add number of reciprocal edges to results df
      results$numEdges[results$reassess == g & results$combo == c & results$loop == m] <- numEdges
      results$intersectLast[results$reassess == g & results$combo == c & results$loop == m] <- intersectLast
      results$num_groups[results$reassess == g & results$combo == c & results$loop == m] <- num_groups
      results$num_isolates[results$reassess == g & results$combo == c & results$loop == m] <- num_isolates
      results$num_four[results$reassess == g & results$combo == c & results$loop == m] <- num_four
      results$assort_association[results$reassess == g & results$combo == c & results$loop == m] <- assortativity(igraph_list[[g]], V(igraph_list[[g]])$association)
      
      
    }
    
    
#    lastGraphs[[c]] <- igraph_list[[reassessments]]
    
    print(c)
    
    
  }


results$numEdges[results$reassess == 1] <- 0
results$intersectLast[results$reassess == 2] <- 0
results$num_isolates[results$reassess == 1] <- 100

results$prims <- primies$prim_abbrev[match(results$combo, rownames(primies))]


}


end.time <- Sys.time()

print(end.time - start.time)



```

### Analysis

```{r analysis}


#calculate percent of edges that are present in previous reassessment period
results$percentPersist <- (results$intersectLast/results$numEdges)*100




#Plots

#Edge Amount Plot#
#plot the number of reciprocated edges throughout reassessment periods [average this across loops w SE]

edges_plot <- ggplot(data = results,
       aes(x = reassess,
           y = numEdges,
           #color = as.factor(loop),
           #groups = as.factor(loop)
       )) +
  facet_wrap(~prims) +
  labs(title = "Number of Edges",
       subtitle = "last 100 reassessments across model loops for each primitive combo",
       x = "reassessment period",
       y = "percent persist"
       #color = "loop") 
       )+
  geom_smooth(se = F) +
  geom_hline(yintercept = 300, linetype = "dashed")

print(edges_plot)



#Edge Persistence Plot#
#plot the percent of edges that persist for each combo across model loops
persist_plot <- ggplot(data = results,
       aes(x = reassess,
           y = percentPersist,
           #color = as.factor(loop),
           #groups = as.factor(loop)
       )) +
  facet_wrap(~prims) +
  labs(title = "Percent of Edges that Persist from Previous Reassessment Period",
       subtitle = "last 100 reassessments across model loops for each primitive combo",
       x = "reassessment period",
       y = "percent persist"
       #color = "loop"
       ) +
  geom_smooth(se = F) +
  geom_hline(yintercept = 100, linetype = "dashed")

print(persist_plot)



#Ranks

#subset results df to only tail entries (after model converges)
resultsTail <- results[results$reassess > 200,]

#calculate mean edge persistence, association val assortativity, and number of isolates 

edgesTail <- resultsTail %>%
  group_by(prims) %>%
  summarize(
    meanEdges = mean(numEdges, na.rm = TRUE),
    sdEdges = sd(numEdges, na.rm = TRUE),
    .groups = "drop"
  )

persistTail <- resultsTail %>%
  group_by(prims) %>%
  summarize(
    meanPersist = mean(percentPersist, na.rm = TRUE),
    sdPersist = sd(percentPersist, na.rm = TRUE),
    .groups = "drop"
  )

assortTail <- resultsTail %>%
  group_by(prims) %>%
  summarize(
    meanAssort = mean(assort_association, na.rm = TRUE),
    sdAssort = sd(assort_association, na.rm = TRUE),
    .groups = "drop"
  )

isolatesTail <- resultsTail %>%
  group_by(prims) %>%
  summarize(
    meanIsolates = sum(num_isolates, na.rm = TRUE),
#    sdIsolates = sd(num_isolates, na.rm = TRUE),
    .groups = "drop"
  )


resultsLast <- results[results$reassess == 300,]





#add vertex attributes
for(r in 1:length(igraph_list)) {
  
  V(igraph_list[[r]])$name <- c(1:100)
  
  V(igraph_list[[r]])$color <- agents$color[match(V(igraph_list[[r]])$name, rownames(agents))]
  
  #V(igraph_list[[r]])$pursuitAmount <- agents$pursuit_amount[match(V(igraph_list[[r]])$name, rownames(agents))]

  
}

V(lastGraphs[[15]])$color <- agents$color[match(V(lastGraphs[[15]])$name, rownames(agents))]


#create vector of unique association values in order 
associationVals <- sort(unique(agents$association))

#create color ramp palette
cols <- setNames(colorRampPalette(c("red", "yellow", "green"))(length(associationVals)), associationVals)

# initialize color vector
vertColors <- rep(NA, popSize)

# assign colors based on association values
for (i in 1:nrow(agents)) {
  
  a <- agents$association[i]
  
  agents$color[i] <- cols[as.character(a)]
}



plot(lastGraphs[[16]],
     layout = layout.fruchterman.reingold,
     vertex.label = NA,
     #  rescale = F,
     layout = layout_with_kk,
     vertex.size = 8,
     #vertex.color = vertex.color,
     vertex.label.color = "black",
     vertex.shape = "circle",
     edge.arrow.size = 0.3)


summary_df <- resultsTail %>%
  group_by(prims) %>%
   summarize(
    Mean_Persistence = mean(percentPersist, na.rm = TRUE),
    Mean_Similarity = mean(assort_association, na.rm = TRUE),
    Total_Isolates = sum(num_isolates, na.rm = T),
    Mean_four = mean(num_four, na.rm = T),
    .groups = "drop"
  )


meanPers<- ggplot(summary_df, aes(x = prims, y = Mean_Persistence, color = prims)) +
  geom_point(size = 5) +
  geom_segment(aes(xend = prims, y = 0, yend = Mean_Persistence), color = "grey70", linewidth = 0.5) +
  geom_text(aes(label = round(Mean_Persistence, 1)), vjust = -1, size = 3.5) +
  labs(
    title = "Percent of Ties that Persist from Previous Round",
    subtitle = "for final 100 regrouping periods",
    y = "percent of edges",
    x = NULL
  ) +
  theme_bw() +
  theme(legend.position = "right")



meanIso <- ggplot(summary_df, aes(x = prims, y = Total_Isolates, color = prims)) +
  geom_point(size = 5) +
  geom_segment(aes(xend = prims, y = 0, yend = Total_Isolates), color = "grey70", linewidth = 0.5) +
  geom_text(aes(label = Total_Isolates), vjust = -1, size = 3.5) +
  labs(
    title = "Number of Isolates in Last Reassessment Period",
    y = "number of isolates",
    x = NULL
  ) +
  theme_bw() +  theme(legend.position = "right")


meanFour <- ggplot(summary_df, aes(x = prims, y = Mean_four, color = prims)) +
  geom_point(size = 5) +
  geom_segment(aes(xend = prims, y = 0, yend = Mean_four), color = "grey70", linewidth = 0.5) +
  geom_text(aes(label = Mean_four), vjust = -1, size = 3.5) +
  labs(
    title = "Average Number of Groups of 4",
    subtitle = "within final 100 regrouping periods",
    y = "number of isolates",
    x = NULL
  ) +
  theme_bw() +  theme(legend.position = "right")





ggsave(plot = meanFour, filename = "meanFour.png", dpi = 300)

cliques(lastGraphs[[16]], min = 3, max = 10)


```

















